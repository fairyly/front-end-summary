# 垃圾回收机制
>垃圾收集机制原理：  
垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）， 周期性地执行这一操作：  
找出那些不再继续使用的变量，然后释放其占用的内存。


## 1.标记清除

JavaScript中最重用的垃圾收集方式是标记清除（mark-and-sweep）。Take is cheap, let me show you the code.

 

>当运行addTen()这个函数的时候，就是当变量进入环境时，就将这个变量标记为“进入环境”。    
从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。  
而当变量离开环境时，则将其标记为“离开环境”。



## 2.引用计数

另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。

>当声明了一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1.  
如果同一个值又被赋给另外一个变量，则该值得引用次数加1。  
相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。  
当这个值的引用次数变成 0  时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。  
这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。 

问题：循环引用。

假如这个函数被重复多次调用，就会导致大量内存得不到回收。  

为此放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。  

可是，引用计数导致的麻烦并未就此终结。

IE 中有一部分对象并不是原生 JavaScript 对象。  
例如，其 BOM 和 DOM 中的对象就是使用 C++以 COM（Component Object Model，组件对象模型）对象的形式实现的，  
而 COM对象的垃圾 收集机制采用的就是引用计数策略。

因此，即使 IE的 JavaScript引擎是使用标记清除策略来实现的，  
但 JavaScript访问的 COM对象依然是基于引用计数策略的。  
换句话说，只要在IE中涉及 COM对象，就会存在循环引用的问题。

## 参考
- [JavaScript垃圾收集-标记清除和引用计数](https://www.cnblogs.com/scottjeremy/p/6870729.html)
- [js的内存泄漏场景、监控以及分析](https://www.cnblogs.com/dasusu/p/12200176.html)
